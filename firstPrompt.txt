You are helping design and implement Atrius, a real-time, cross-platform file synchronization system built specifically for game assets and other large binary files. Atrius is not a Git client, not a cloud drive, and not a folder-based sync tool. It does not rely on repositories, directories, or project structures. Instead, Atrius is fundamentally file-centric: individual files are treated as first-class entities that can be independently synced, tracked, locked, versioned, and shared across devices.

The core problem Atrius solves is the friction involved in moving specific assets between devices during game and digital product development. Designers frequently create assets on different hardware, such as drawing sprites on an iPad or editing audio on a laptop, and then must manually export, upload, or commit those assets to make them available elsewhere. Atrius eliminates this friction by allowing a user to select a single file and have that file propagate automatically and almost immediately to every other device where it is connected. A designer should be able to edit a texture on an iPad, save it, and see that same texture update on a Windows or macOS machine within seconds, without any manual sync action, export step, or repository workflow.

Atrius operates under several non-negotiable product principles that must guide every technical decision. Syncing is always performed at the file level, never at the folder or repository level. Changes must propagate in real time or near real time. The system must support large binary files such as textures, audio files, and 3D models. Cross-platform support is required from the start, including Windows, macOS, iOS, and iPadOS, with consistent behavior across devices. Files must push updates immediately while still maintaining visible version history. Silent overwrites are not allowed under any circumstances, and every synced file requires explicit user consent and control.

The MVP for Atrius is a working desktop and mobile application backed by a core synchronization engine that supports explicit selection of individual files for syncing. Each file exists independently of any directory structure and can be added to or removed from sync at any time. For every synced file, the system must maintain a unique identity, a list of connected devices, a current sync state, lightweight version history, and information about the device that originated the most recent change. Sync state must clearly indicate whether a file is up to date, actively syncing, locked, or in an error state. File syncing must continue in the background, resume automatically after network interruptions, and require no manual “sync” button.

The system must prioritize asset safety. Atrius must include a basic file locking mechanism, with support for both manual locks and optional automatic locks on edit. Lock state must be visible across all connected devices. Conflicts must never result in silent overwrites; when conflicts occur, they must produce a clear error or resolution state, using simple rules such as last-write-wins or explicit user choice. Lightweight versioning must be supported so that recent versions of a file can be viewed and rolled back if necessary. All transfers must be encrypted, devices must be authenticated, and unsynced files must never be accessed without explicit user approval.

Several categories of functionality are explicitly out of scope for the MVP and must not influence the design. These include branching workflows, Git compatibility, folder-wide auto-sync, game engine plugins, advanced merge tools, team communication features, or any form of asset marketplace or cloud hosting platform. Atrius is not trying to replace source control; it is solving a different, narrower problem focused on real-time asset movement across devices.

The first and most critical engineering step is to design the core file-centric data model. You must design a system where individual files are treated as independent entities, each with its own identity, sync state, version history, and connected devices, completely independent of directory structure. This design must define how a file is uniquely identified in a way that does not depend on file paths, how metadata is stored locally versus shared across devices, how sync state is tracked on a per-device basis, how versions are recorded and referenced, and how file locks are represented and enforced.

This step must also define a local file registry that maps stable file identities to local file paths while allowing files to be renamed or moved without losing identity. The registry must persist across application restarts and must not assume ownership of any folder or directory. The design must clearly answer what makes a file “the same file” across devices, how renames or moves do not break that identity, how a file can exist on some devices but not others, and how a file can be safely removed from sync without affecting other files or devices.

At this stage, you should focus on architecture, data structures, state transitions, and invariants rather than production code. If code is used, it should only exist to clarify the model. You should propose the core structs or classes that represent a synced file, its metadata, its versions, and its device relationships, and clearly explain the invariants that must always hold true for the system to function correctly. This data model is the foundation that everything else depends on; if it is flawed, the entire product breaks. Your output should explain the proposed file-entity model in detail, justify design decisions in relation to Atrius’s product goals, and clearly state any assumptions you are making, without introducing features beyond the defined MVP scope.
